<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini-arène (prototype)</title>
<style>
  html,body { height:100%; margin:0; background:#111; color:#eee; font-family:Arial,Helvetica,sans-serif; }
  #gameWrap{ display:flex; height:100vh; align-items:center; justify-content:center; position:relative; }
  canvas { background:#2b7; border:6px solid #222; box-shadow:0 6px 30px rgba(0,0,0,0.6); }
  .ui {
    position:absolute; right:18px; bottom:18px; z-index:20; display:flex; flex-direction:column; gap:8px;
  }
  .btn {
    background:#0b84ff; color:white; border:none; padding:10px 14px; border-radius:8px; cursor:pointer;
    font-weight:700; box-shadow:0 4px 14px rgba(11,132,255,0.35);
  }
  .panel {
    position:absolute; left:18px; top:18px; background:rgba(0,0,0,0.55); padding:12px; border-radius:8px;
    min-width:200px; color:#fff;
  }
  .row { margin:6px 0; }
  label{display:block; font-size:13px; margin-bottom:6px;}
  select,input[type=color] { width:100%; padding:6px; border-radius:6px; border:1px solid #444; background:#222; color:#fff;}
  #overlayScreen {
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center; z-index:30;
    pointer-events:none;
  }
  .screenBox {
    pointer-events:auto;
    background:rgba(10,10,10,0.9); color:#fff; padding:24px; border-radius:10px; text-align:center; width:min(600px,90%);
    box-shadow:0 10px 40px rgba(0,0,0,0.7);
  }
  .screenBox h1{ margin:0 0 12px; font-size:28px; }
  .hud {
    position:absolute; left:50%; transform:translateX(-50%); top:12px; z-index:25; color:#fff; text-align:center;
  }
  .barWrap { width:260px; height:14px; background:#333; border-radius:8px; overflow:hidden; margin:0 auto; border:1px solid #222;}
  .bar { height:100%; background:linear-gradient(90deg,#00d08a,#00a68f); width:100%; }
  .infoRow{display:flex; gap:12px; justify-content:center; margin-top:8px; font-size:14px;}
  .small { font-size:12px; opacity:0.9; }
</style>
</head>
<body>
<div id="gameWrap">
  <canvas id="c" width="1000" height="600"></canvas>

  <!-- left panel: choix skin/arme -->
  <div class="panel" id="panel">
    <div class="row">
      <label>Choisir le skin (aperçu simple)</label>
      <select id="skinSelect">
        <option value="0">Skin Bleu (par défaut)</option>
        <option value="1">Skin Rouge</option>
        <option value="2">Skin Vert</option>
        <option value="3">Skin Jaune</option>
      </select>
    </div>
    <div class="row">
      <label>Choisir l'arme</label>
      <select id="weaponSelect">
        <option value="pistol">Pistolet (10 coups, recharg.)</option>
        <option value="shotgun">Pompe (shotgun, gros dégâts courte portée)</option>
        <option value="sniper">Sniper (1 balle tue, délai de tir)</option>
        <option value="smg">Mitraillette (cadence élevée)</option>
      </select>
    </div>
    <div class="row small">Déplacements AZERTY: <strong>Z Q S D</strong> • Tir: <strong>Clic gauche</strong> • Recharger: <strong>R</strong></div>
  </div>

  <!-- HUD center top -->
  <div class="hud" id="hud">
    <div class="barWrap"><div id="hpBar" class="bar" style="width:100%"></div></div>
    <div class="infoRow">
      <div id="hpText">Vie: 10 / 10</div>
      <div id="ammoText">Ammo: 10 / 10</div>
    </div>
  </div>

  <!-- bottom-right UI -->
  <div class="ui">
    <button id="joinBtn" class="btn">Simuler 2ème joueur</button>
    <button id="playBtn" class="btn">JOUER</button>
  </div>

  <!-- overlay screens -->
  <div id="overlayScreen"></div>
</div>

<script>
/* --------------------------
   Prototype Arène 2D (pseudo-3D)
   - AZERTY controls (ZQSD)
   - Weapons: pistol(10), shotgun, sniper, smg
   - Ennemis intelligents (repositionnement, visée approximative, reload)
   - Tous les armes font 1 dégât
   - Joueur a 10 vies
   - Après 5 tirs consécutifs -> reload forcé 3000ms
   - Map color random each round
   - Pre-game UI: choose skin + weapon
   - "Simuler 2ème joueur" simule l'attente d'un autre joueur.
   -------------------------- */

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let W = canvas.width, H = canvas.height;

// Game state
let game = {
  running:false,
  roundStartTime:0,
  bgColor:'#2b7',
  players:[], // local player only for now
  enemies: [],
  bullets: [],
  roundWinner:null,
  lobbySimulated:false
};

// Settings UI
const skinSelect = document.getElementById('skinSelect');
const weaponSelect = document.getElementById('weaponSelect');
const playBtn = document.getElementById('playBtn');
const joinBtn = document.getElementById('joinBtn');
const overlayScreen = document.getElementById('overlayScreen');
const hudHpBar = document.getElementById('hpBar');
const hpText = document.getElementById('hpText');
const ammoText = document.getElementById('ammoText');

function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function rnd(min,max){ return Math.random()*(max-min)+min; }

// Entities sizes (Fortnite-like squares)
const PLAYER_SIZE = 44;
const ENEMY_SIZE = 44;

// Controls (AZERTY)
const keys = { z:false,q:false,s:false,d:false, r:false };
window.addEventListener('keydown',(e)=>{
  const k=e.key.toLowerCase();
  if(k==='z') keys.z=true;
  if(k==='q') keys.q=true;
  if(k==='s') keys.s=true;
  if(k==='d') keys.d=true;
  if(k==='r') keys.r=true;
});
window.addEventListener('keyup',(e)=>{
  const k=e.key.toLowerCase();
  if(k==='z') keys.z=false;
  if(k==='q') keys.q=false;
  if(k==='s') keys.s=false;
  if(k==='d') keys.d=false;
  if(k==='r') keys.r=false;
});

// Mouse aim & click
let mouse = { x:W/2, y:H/2, down:false };
canvas.addEventListener('mousemove', e=>{
  const rect = canvas.getBoundingClientRect();
  mouse.x = e.clientX - rect.left;
  mouse.y = e.clientY - rect.top;
});
canvas.addEventListener('mousedown', e=>{ if(e.button===0) mouse.down = true; });
canvas.addEventListener('mouseup', e=>{ if(e.button===0) mouse.down = false; });

// Basic weapon definitions
// ALL weapons dmg set to 1 as requested
const WEAPONS = {
  pistol: { name:'Pistolet', mag:10, fireRate: 300, bulletSpeed:700, dmg:1, reloadTime:900, spread:6 },
  shotgun: { name:'Pompe', mag:6, fireRate:900, bulletSpeed:600, dmg:1, pellets:6, pelletSpread:18, reloadTime:1400 },
  sniper: { name:'Sniper', mag:1, fireRate:2000, bulletSpeed:1200, dmg:1, reloadTime:1800, scope:true }, // now 1 dmg
  smg: { name:'Mitraillette', mag:30, fireRate:80, bulletSpeed:900, dmg:1, reloadTime:1100, spread:8 }
};

// Player constructor
function createPlayer(){
  const skin = parseInt(skinSelect.value,10)||0;
  const weaponKey = weaponSelect.value || 'pistol';
  const weapon = Object.assign({}, WEAPONS[weaponKey]);
  weapon.key = weaponKey;
  weapon.ammo = weapon.mag;
  return {
    id:'p1',
    x:W/2, y:H/2,
    vx:0, vy:0,
    size:PLAYER_SIZE,
    speed:200,
    hp:10,           // <-- player has 10 hp now
    maxHp:10,
    skin,
    weapon,
    canFire:true,
    lastFire:0,
    reloading:false,
    alive:true,
    shotsSinceAutoReload:0  // count shots to force reload every 5 shots
  };
}

// Enemy AI
function createEnemy(i){
  return {
    id:'e'+i,
    x: randInt(80, W-80),
    y: randInt(80, H-80),
    size:ENEMY_SIZE,
    speed: 120,
    hp:3,
    maxHp:3,
    state:'patrol', // patrol / engage / reload / moveTo
    targetPoint: null,
    reactionTime: rnd(300,1200), // delay to react shooting
    lastSeeTime:0,
    lastAction:0,
    weapon: (()=>{ // pick a weapon variety
      const keys = ['pistol','shotgun','smg'];
      const k = randChoice(keys);
      const w = Object.assign({}, WEAPONS[k]);
      w.key = k;
      w.ammo = w.mag;
      return w;
    })(),
    alive:true,
    aimNoise: rnd(3,10), // in degrees
    shotsSinceAutoReload:0
  };
}

// bullets
// {x,y,vx,vy,owner,dmg,life,weaponKey}
function spawnBullet(x,y,dx,dy,owner,weaponKey,dmg){
  game.bullets.push({
    x,y,vx:dx, vy:dy, owner, dmg, life:2000, weaponKey
  });
}

// Start Round
function startRound(){
  // reset
  game.bullets = [];
  game.enemies = [];
  game.players = [];
  game.roundWinner = null;
  game.roundStartTime = performance.now();
  game.bgColor = `hsl(${randInt(0,360)} ${randInt(40,70)}% ${randInt(35,55)}%)`;

  const p = createPlayer();
  game.players.push(p);

  // spawn 1 smart enemy (as requested)
  for(let i=0;i<1;i++) game.enemies.push(createEnemy(i+1));

  game.running = true;
  overlayScreen.innerHTML = '';
  updateHUD();
}

// Simulate other player join (local)
joinBtn.addEventListener('click', ()=>{
  // toggles simulated join
  game.lobbySimulated = !game.lobbySimulated;
  joinBtn.textContent = game.lobbySimulated ? '2ème joueur présent (simulé)' : 'Simuler 2ème joueur';
});

// Play button behavior: if simulated join present, start immediately; else start and wait 1.5s for "other"
playBtn.addEventListener('click', ()=>{
  if(game.lobbySimulated){
    startRound();
  } else {
    // show waiting message for brief moment then start
    showOverlayMessage('En attente d’un autre joueur… (simulation)', 1500, startRound);
  }
});

// Overlay helper
function showOverlayMessage(msg, ms, cb){
  overlayScreen.innerHTML = `<div class="screenBox"><h1>${msg}</h1></div>`;
  setTimeout(()=>{
    overlayScreen.innerHTML = '';
    if(cb) cb();
  }, ms);
}

// Gameplay loop
let lastTime = performance.now();
function loop(now){
  const dt = Math.min(50, now - lastTime) / 1000;
  lastTime = now;
  update(dt);
  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// Update HUD
function updateHUD(){
  const p = game.players[0];
  if(!p) return;
  const pct = Math.max(0, p.hp / p.maxHp) * 100;
  hudHpBar.style.width = pct + '%';
  hpText.textContent = `Vie: ${p.hp} / ${p.maxHp}`;
  ammoText.textContent = `Ammo: ${p.weapon.ammo} / ${p.weapon.mag}`;
}

// Game update
function update(dt){
  if(!game.running) return;

  const p = game.players[0];
  if(!p || !p.alive) return;

  // movement AZERTY
  let mx=0,my=0;
  if(keys.z) my -= 1;
  if(keys.s) my += 1;
  if(keys.q) mx -= 1;
  if(keys.d) mx += 1;
  // normalize
  if(mx!==0 || my!==0){
    const len = Math.hypot(mx,my);
    mx /= len; my /= len;
    p.x += mx * p.speed * dt;
    p.y += my * p.speed * dt;
  }

  // clamp on map edges
  p.x = Math.max(p.size/2, Math.min(W - p.size/2, p.x));
  p.y = Math.max(p.size/2, Math.min(H - p.size/2, p.y));

  // firing
  handleFiring(p, dt, true);

  // reload key
  if(keys.r && !p.reloading && p.weapon.ammo < p.weapon.mag){
    reloadWeapon(p);
  }

  // Update bullets
  for(let i=game.bullets.length-1;i>=0;i--){
    const b = game.bullets[i];
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    b.life -= dt*1000;
    // remove if out of bounds or life <=0
    if(b.life <= 0 || b.x< -50 || b.x>W+50 || b.y<-50 || b.y>H+50){
      game.bullets.splice(i,1);
      continue;
    }

    // collision with enemies/players
    if(b.owner === 'p1'){
      // hit enemy?
      for(let j=0;j<game.enemies.length;j++){
        const e = game.enemies[j];
        if(!e.alive) continue;
        if(pointInRect(b.x,b.y,e.x-e.size/2,e.y-e.size/2,e.size,e.size)){
          // apply damage
          applyDamageToEnemy(e, b);
          game.bullets.splice(i,1);
          break;
        }
      }
    } else {
      // bullet from enemy -> hit player
      if(p.alive && pointInRect(b.x,b.y,p.x-p.size/2,p.y-p.size/2,p.size,p.size)){
        p.hp -= b.dmg;
        game.bullets.splice(i,1);
        if(p.hp <= 0){
          p.alive = false;
          game.running = false;
          showEndScreen(false);
        }
        updateHUD();
      }
    }
  }

  // Update enemies AI
  game.enemies.forEach(enemyAIUpdate.bind(null, dt));
  // check enemy death => win
  const aliveEnemies = game.enemies.filter(e=>e.alive);
  if(aliveEnemies.length===0){
    game.running = false;
    showEndScreen(true);
  }
}

// helper: point in rect
function pointInRect(px,py,rx,ry,rw,rh){
  return px>=rx && px<=rx+rw && py>=ry && py<=ry+rh;
}

// apply damage to enemy
function applyDamageToEnemy(e, bullet){
  if(!e.alive) return;
  // all weapons now do 1 dmg
  if(bullet.weaponKey==='sniper'){
    // sniper still only deals 1 (per your request)
    e.hp -= 1;
  } else {
    e.hp -= bullet.dmg;
  }
  if(e.hp <= 0){
    e.alive = false;
  }
}

// reload
function reloadWeapon(entity){
  if(entity.reloading) return;
  entity.reloading = true;
  const t = entity.weapon.reloadTime || 1000;
  setTimeout(()=>{ entity.weapon.ammo = entity.weapon.mag; entity.reloading = false; entity.shotsSinceAutoReload = 0; updateHUD(); }, t);
}

// Forced auto-reload (used when 5 shots fired)
function forcedAutoReload(entity){
  if(entity.reloading) return;
  entity.reloading = true;
  // 3 seconds forced reload
  setTimeout(()=>{ entity.weapon.ammo = entity.weapon.mag; entity.reloading = false; entity.shotsSinceAutoReload = 0; updateHUD(); }, 3000);
}

// handle firing for a shooter (player or enemy)
function handleFiring(shooter, dt, isPlayer){
  const weapon = shooter.weapon;
  if(shooter.reloading) return;
  // compute angle
  let aimX, aimY;
  if(isPlayer){
    aimX = mouse.x; aimY = mouse.y;
  } else {
    // enemies aim towards player with some noise; choose target as player's current position
    const p = game.players[0];
    if(!p) return;
    // sometimes aim slightly ahead based on player's velocity
    aimX = p.x + (p.vx||0) * 0.3 * 100;
    aimY = p.y + (p.vy||0) * 0.3 * 100;
    // add noise
    const angNoise = degToRad( rnd(-shooter.aimNoise, shooter.aimNoise) );
    const dx = aimX - shooter.x, dy = aimY - shooter.y;
    const ang = Math.atan2(dy,dx) + angNoise;
    aimX = shooter.x + Math.cos(ang)*100;
    aimY = shooter.y + Math.sin(ang)*100;
  }

  // firing logic (rate limiting)
  const now = performance.now();
  if(weapon.key==='shotgun'){
    // shotgun: fires multiple pellets if trigger
    if((isPlayer && mouse.down) || (!isPlayer && canEnemySeeAndWantToShoot(shooter))){
      const can = now - (shooter.lastFire||0) > weapon.fireRate;
      if(can && weapon.ammo>0){
        shooter.lastFire = now;
        weapon.ammo--;
        shooter.shotsSinceAutoReload = (shooter.shotsSinceAutoReload||0) + 1;
        // pellets
        for(let i=0;i<weapon.pellets;i++){
          const baseAng = Math.atan2(aimY - shooter.y, aimX - shooter.x);
          const spr = degToRad( rnd(-weapon.pelletSpread, weapon.pelletSpread) );
          const ang = baseAng + spr;
          const speed = weapon.bulletSpeed;
          spawnBullet(shooter.x, shooter.y, Math.cos(ang)*speed, Math.sin(ang)*speed, isPlayer ? 'p1' : shooter.id, weapon.key, weapon.dmg);
        }
        if(isPlayer) updateHUD();
        // if reached 5 shots -> forced reload 3s
        if((shooter.shotsSinceAutoReload||0) >= 5){
          forcedAutoReload(shooter);
        } else if(weapon.ammo===0){
          reloadWeapon(shooter);
        }
      }
    }
  } else {
    // normal bullets
    if((isPlayer && mouse.down) || (!isPlayer && canEnemySeeAndWantToShoot(shooter))){
      const can = now - (shooter.lastFire||0) > weapon.fireRate;
      if(can && weapon.ammo>0){
        shooter.lastFire = now;
        weapon.ammo--;
        shooter.shotsSinceAutoReload = (shooter.shotsSinceAutoReload||0) + 1;
        const ang = Math.atan2(aimY - shooter.y, aimX - shooter.x);
        const spreadDeg = weapon.spread || 0;
        const angWithSpread = ang + degToRad( rnd(-spreadDeg, spreadDeg) );
        const speed = weapon.bulletSpeed;
        spawnBullet(shooter.x, shooter.y, Math.cos(angWithSpread)*speed, Math.sin(angWithSpread)*speed, isPlayer ? 'p1' : shooter.id, weapon.key, weapon.dmg);
        if(isPlayer) updateHUD();
        // forced reload after 5 shots
        if((shooter.shotsSinceAutoReload||0) >= 5){
          forcedAutoReload(shooter);
        } else if(weapon.ammo===0){
          reloadWeapon(shooter);
        }
      }
    }
  }
}

// enemy decision: whether they want to shoot (line of sight, reaction delay)
function canEnemySeeAndWantToShoot(enemy){
  const p = game.players[0];
  if(!p || !p.alive || !enemy.alive) return false;
  // simple line-of-sight: check distance and angle; also random chance to simulate human
  const dx = p.x - enemy.x, dy = p.y - enemy.y;
  const dist = Math.hypot(dx,dy);
  if(dist > 700) return false;
  // reaction time
  const now = performance.now();
  if(now - enemy.lastSeeTime < enemy.reactionTime) {
    // update last see time when first noticing
    enemy.lastSeeTime = now;
    return false;
  }
  // if recently moved or reloading, less likely to shoot
  if(enemy.reloading) return false;
  // Always allow shooting if within range and there's ammo
  return enemy.weapon.ammo > 0;
}

// enemy AI update
function enemyAIUpdate(dt, enemy){
  if(!enemy.alive) return;
  const p = game.players[0];
  if(!p || !p.alive) return;

  const now = performance.now();

  // possibly change target point occasionally to make movement "human"
  if(!enemy.targetPoint || now - enemy.lastAction > randInt(1000,3000)){
    enemy.targetPoint = { x: randInt(80, W-80), y: randInt(80, H-80) };
    enemy.lastAction = now;
  }

  // Move towards or strafe depending on distance
  const dx = enemy.targetPoint.x - enemy.x;
  const dy = enemy.targetPoint.y - enemy.y;
  const distToPoint = Math.hypot(dx,dy);
  if(distToPoint > 8){
    const nx = dx/distToPoint, ny = dy/distToPoint;
    enemy.x += nx * enemy.speed * dt;
    enemy.y += ny * enemy.speed * dt;
  } else {
    // once arrived, possibly pick new point
    if(Math.random() < 0.01) enemy.targetPoint = null;
  }

  // decide to engage player: sometimes move to flank
  const pdx = p.x - enemy.x, pdy = p.y - enemy.y;
  const pdist = Math.hypot(pdx,pdy);
  // If close, strafe randomly
  if(pdist < 260 && Math.random() < 0.02){
    // quick strafe
    const angle = Math.atan2(pdy,pdx) + (Math.random()>0.5 ? Math.PI/2 : -Math.PI/2);
    enemy.x += Math.cos(angle) * 30;
    enemy.y += Math.sin(angle) * 30;
  }

  // keep inside bounds
  enemy.x = Math.max(enemy.size/2, Math.min(W - enemy.size/2, enemy.x));
  enemy.y = Math.max(enemy.size/2, Math.min(H - enemy.size/2, enemy.y));

  // shooting logic: enemies will try to shoot when they "decide" to
  // Simulate reloading
  if(enemy.weapon.ammo <= 0 && !enemy.reloading){
    enemy.reloading = true;
    setTimeout(()=>{ enemy.weapon.ammo = enemy.weapon.mag; enemy.reloading=false; enemy.shotsSinceAutoReload=0; }, enemy.weapon.reloadTime || 1000);
    return;
  }

  // decide to shoot based on perceived line of sight and probability
  // We add a small probability to "hesitate" before shooting.
  if(canEnemySeeAndWantToShoot(enemy) && (Math.random() < 0.025 || pdist < 300)){
    handleFiring(enemy, dt, false);
  }
}

// rendering
function render(){
  // clear background with map color
  ctx.fillStyle = game.bgColor;
  ctx.fillRect(0,0,W,H);

  // draw arena grid / pseudo-3D effect: a faint isometric grid
  drawArenaGrid();

  // draw bullets
  game.bullets.forEach(b=>{
    ctx.beginPath();
    if(b.owner === 'p1') ctx.fillStyle = '#ffeb3b';
    else ctx.fillStyle = '#ff6161';
    ctx.arc(b.x,b.y,4,0,Math.PI*2);
    ctx.fill();
  });

  // draw enemies as squares with simple "skin" (bust like fortnite)
  game.enemies.forEach(e=>{
    if(!e.alive) return;
    drawCharacter(e.x, e.y, e.size, '#d14', '#8a0', e.hp / e.maxHp);
  });

  // draw player last so it's on top
  const p = game.players[0];
  if(p){
    if(p.alive){
      const skinColor = getSkinColor(p.skin);
      drawCharacter(p.x, p.y, p.size, skinColor, '#333', p.hp / p.maxHp, true, p.weapon.key);
    } else {
      // dead: draw corpse
      ctx.fillStyle = '#400';
      ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
    }
  }

  // draw crosshair
  drawCrosshair(mouse.x, mouse.y);
}

// draw grid / pseudo-3D arena floor
function drawArenaGrid(){
  const spacing = 40;
  ctx.save();
  ctx.globalAlpha = 0.08;
  ctx.lineWidth = 1;
  ctx.strokeStyle = '#000';
  for(let x=0;x<W;x+=spacing){
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
  }
  for(let y=0;y<H;y+=spacing){
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  }
  ctx.restore();
}

// draw a character as a "Fortnite-like" box (body + head + gun)
function drawCharacter(x,y,size, color, trimColor, healthPct, drawGun=false, weaponKey='pistol'){
  // shadow / pseudo 3D
  ctx.save();
  // shadow under character
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.beginPath();
  ctx.ellipse(x, y + size*0.5, size*0.85, size*0.28, 0, 0, Math.PI*2);
  ctx.fill();

  // body
  const w = size * 0.9, h = size * 0.9;
  ctx.fillStyle = color;
  ctx.fillRect(x - w/2, y - h/2, w, h);

  // head
  const headW = w*0.6, headH = h*0.28;
  ctx.fillStyle = shade(color, -10);
  ctx.fillRect(x - headW/2, y - h/2 - headH*0.3, headW, headH);

  // trim / outline
  ctx.strokeStyle = trimColor;
  ctx.lineWidth = 2;
  ctx.strokeRect(x - w/2, y - h/2, w, h);

  // health bar above
  const barW = w, barH = 6;
  ctx.fillStyle = '#333';
  ctx.fillRect(x - barW/2, y - h/2 - 16, barW, barH);
  ctx.fillStyle = '#0bda85';
  ctx.fillRect(x - barW/2, y - h/2 - 16, barW * (healthPct||0), barH);

  // gun rendering
  if(drawGun){
    drawGunOn(ctx, x, y, weaponKey);
  } else {
    // show small weapon for enemies (directionless)
    ctx.fillStyle = '#222';
    ctx.fillRect(x + w*0.25, y - 4, 18, 6);
  }

  ctx.restore();
}

// draw gun pointing towards mouse for player
function drawGunOn(ctx, x, y, weaponKey){
  const dx = mouse.x - x, dy = mouse.y - y;
  const ang = Math.atan2(dy,dx);

  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(ang);
  // gun base rectangle
  ctx.fillStyle = '#222';
  // different guns: scale & color
  if(weaponKey === 'pistol'){
    ctx.fillStyle = '#111';
    ctx.fillRect(12, -6, 34, 12);
    ctx.fillStyle = '#666';
    ctx.fillRect(-6, -6, 20, 12);
  } else if(weaponKey === 'shotgun'){
    ctx.fillStyle = '#2b2';
    ctx.fillRect(12, -8, 48, 16);
    ctx.fillStyle = '#111';
    ctx.fillRect(-6, -8, 24, 16);
  } else if(weaponKey === 'sniper'){
    ctx.fillStyle = '#111';
    ctx.fillRect(12, -5, 64, 10);
    ctx.fillStyle = '#444';
    ctx.fillRect(-8, -6, 24, 12);
  } else if(weaponKey === 'smg'){
    ctx.fillStyle = '#3a3aff';
    ctx.fillRect(12, -6, 46, 12);
    ctx.fillStyle = '#111';
    ctx.fillRect(-6, -6, 20, 12);
  } else {
    ctx.fillStyle = '#111';
    ctx.fillRect(12, -6, 34, 12);
    ctx.fillRect(-6, -6, 20, 12);
  }
  ctx.restore();
}

// simple crosshair
function drawCrosshair(x,y){
  ctx.save();
  ctx.strokeStyle = '#fff';
  ctx.globalAlpha = 0.9;
  ctx.beginPath();
  ctx.moveTo(x-12,y); ctx.lineTo(x-4,y);
  ctx.moveTo(x+4,y); ctx.lineTo(x+12,y);
  ctx.moveTo(x,y-12); ctx.lineTo(x,y-4);
  ctx.moveTo(x,y+4); ctx.lineTo(x,y+12);
  ctx.stroke();
  ctx.restore();
}

// Utility: shade color
function shade(hex, percent) {
  try{
    if(hex.startsWith('hsl')) return hex;
    hex = hex.replace('#','');
    const r = parseInt(hex.substring(0,2),16);
    const g = parseInt(hex.substring(2,4),16);
    const b = parseInt(hex.substring(4,6),16);
    const t = percent<0?0:255;
    const p = Math.abs(percent)/100;
    const R = Math.round((t - r) * p) + r;
    const G = Math.round((t - g) * p) + g;
    const B = Math.round((t - b) * p) + b;
    return `rgb(${R},${G},${B})`;
  }catch(e){ return hex; }
}

function degToRad(d){ return d * Math.PI / 180; }

// skins color map
function getSkinColor(idx){
  switch(idx){
    case 0: return '#4da6ff'; // blue
    case 1: return '#ff6b6b'; // red
    case 2: return '#5ad66a'; // green
    case 3: return '#ffd166'; // yellow
    default: return '#4da6ff';
  }
}

// show end screen (win true/false)
function showEndScreen(win){
  overlayScreen.innerHTML = `
    <div class="screenBox">
      <h1>${win ? 'VICTOIRE !' : 'DÉFAITE'}</h1>
      <p>Appuie sur <strong>JOUER</strong> pour recommencer.</p>
      <div style="margin-top:12px;">
        <button class="btn" id="restartBtn">Rejouer</button>
      </div>
    </div>
  `;
  document.getElementById('restartBtn').addEventListener('click', ()=>{ startRound(); });
}

// preload: ensure HUD initial values
updateHUD();

/* --- End of script file --- */

</script>
</body>
</html>
